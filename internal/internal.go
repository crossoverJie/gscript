package internal

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"strings"
)

func bindata_read(data []byte, name string) ([]byte, error) {
	gz, err := gzip.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	var buf bytes.Buffer
	_, err = io.Copy(&buf, gz)
	gz.Close()

	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	return buf.Bytes(), nil
}

var _internal_internal_go = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x01\x00\x00\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00")

func internal_internal_go() ([]byte, error) {
	return bindata_read(
		_internal_internal_go,
		"internal/internal.go",
	)
}

var _internal_internal_gs = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xcc\x56\xb1\x8e\x23\x45\x10\xcd\xe7\x2b\x0a\x4b\x9c\xc6\xb2\xb5\xc3\x25\x10\xac\x3a\x42\x07\xab\xd3\x71\x48\x5c\xb8\xda\xa0\xd7\x53\x5e\xf7\x79\xae\x67\xae\xbb\xc7\xb7\x3e\xcb\x12\x82\x88\xe8\x24\x10\x1f\x80\x44\x00\x09\x09\x24\x24\xfc\xcd\xae\x8e\xbf\x40\x55\xdd\xe3\xee\x19\x8f\x75\xda\x8c\x49\xec\xa9\x7e\x55\xf5\xaa\xea\x95\xdb\x45\x01\x06\x5d\x6b\x34\x48\x63\xe4\x16\x2a\xd4\x37\x6e\x95\x29\xed\xe8\x6b\x2e\xf5\xf6\xf2\x0a\xe4\x74\xb7\xcf\xb2\x08\x5d\x49\xbb\x5a\xd4\x25\x32\x8c\x5e\x08\x07\x96\x51\x8d\x51\xda\x55\x3a\xa7\x17\x69\x2d\x1a\xf7\xe4\x75\x2b\x2b\xff\xde\x34\xa8\xcb\x7c\x10\xed\xe9\x8b\xaf\x9f\x83\x75\x46\xe9\x9b\xcc\x7f\xb0\x89\x63\x72\xe6\xa2\xf0\x98\xd7\x2d\x9a\x2d\xbc\x51\x6e\x05\x8d\x74\xab\x8c\x00\x74\xf0\x25\xba\x3c\x38\xbe\xb4\xb5\x9e\x87\x60\x0c\xe2\x5c\x14\x61\xe5\x5c\x03\x95\xba\xce\xbe\x60\x86\x4b\x4e\x41\xfc\xa9\x90\x9e\xcb\xe1\x85\x82\x91\xff\xa2\x92\xd6\xc2\x85\x73\xcd\xe7\xb5\x76\x78\xeb\x76\x19\x00\xa4\x2e\xe7\x6c\x18\x84\x24\x7a\x9b\xa9\xc7\x26\x78\x8a\x0a\xc2\x83\x37\xd3\xf3\xc3\x71\x51\x74\xad\x9b\x90\xbf\x98\xc0\x8c\x03\xc1\x0c\x26\xec\xc4\x16\xf6\x26\x0b\xa5\x65\x0b\x57\x19\xc3\xa4\xe5\x79\x1e\xbe\x26\x2e\xc6\xc3\xf6\xd9\x3e\xa3\x76\x5c\x48\x5d\x56\x98\xf7\x4a\x5f\xb6\x7a\x01\x9b\x5a\x95\x79\x52\xef\x14\x56\x0c\x0d\xc5\x14\x05\x1c\xa8\x7a\x1a\xb3\x84\x44\xe2\x07\x0b\x77\x0b\x22\xb5\xe4\x01\xe4\xe3\xe5\x0b\x77\x3b\x3d\x0f\x6c\xbe\x69\x75\x47\x45\x96\xa5\xe1\xc1\xf9\xce\x3f\xd1\xce\x6c\x7d\x6a\xea\xe9\x1a\xb7\xf3\x8d\xac\x5a\xf4\xa1\xf8\x14\x34\xde\xba\xe4\x9d\xc5\xb3\x0e\x33\x98\x77\x98\x64\x18\x6b\xdc\x8a\x75\xec\x1a\xc7\x13\x9b\x68\xa0\x78\x42\xc7\x7e\x79\x26\x5f\xc9\x66\x17\x93\x5c\x5e\x81\x93\xd7\x15\x82\x80\xcb\xc7\x9f\x5e\xed\xf6\x1e\x4e\x0a\xb0\xea\x2d\x8a\x4f\xce\x33\x36\x34\xad\xcb\x3b\xe2\x9e\x11\x65\x4b\xc8\x14\x05\xb8\xba\xac\x61\x61\x6a\x6b\xeb\x0d\x9a\xa7\x0a\xe1\xfe\x87\xdf\xef\xfe\xf8\xfb\x80\x51\xcb\x9c\x38\x8b\xc9\x24\x71\xa4\xc7\x6f\x51\x64\xbe\x8f\x2e\x61\x3b\x59\x45\xc2\x2f\xea\x1a\xb7\x89\x58\x08\xa1\xc2\x11\xa3\x3e\xe6\xad\xe7\xaa\xa6\x10\x71\xbe\x7f\x14\x84\x8f\x2e\xd5\x55\x3c\xbb\xae\xeb\x0a\xde\x18\xe5\xf8\xd8\x74\x63\xf1\x9c\x21\x47\xf8\x48\x80\x56\xd5\x80\xb5\x8f\xe8\xf0\x55\xe3\xbf\x09\x48\xfc\xe8\x59\xd6\x06\xf2\x78\x1e\x82\x40\x3f\x4a\x57\xc3\xa2\x35\x06\xb5\xbb\x90\x76\xd5\x15\x7a\x70\x3d\xeb\x97\x9c\x72\xeb\xb9\x25\x5d\x78\xf4\x88\x66\x45\xa6\x7e\x94\xe3\xe4\xf4\x44\x8c\x57\x11\x24\xe2\x1c\x3e\xa1\x4f\x4b\x59\xd9\x13\x88\xe1\x38\xbb\x67\x7f\x64\x49\x9b\x17\x39\xc4\x45\x18\xf7\xec\x06\x08\x22\x6c\x0a\xab\x92\x29\xcf\x01\x07\x8d\xa2\x26\x31\xe5\x91\xd2\x49\xe2\xb3\xd9\x30\x55\x94\x21\x60\x65\x71\x30\xaf\xa2\x80\xbb\x77\xdf\xbd\xff\xf6\x7b\x78\x59\xae\x1f\x9f\x7d\x06\xff\xfe\xf4\xcf\xfb\x5f\x7e\xbb\xfb\xf5\xaf\xfb\x77\x3f\xde\xff\xf9\xf3\x87\x99\x7a\xa2\x24\x85\x7e\xe6\x21\x9b\xc0\x24\x7c\xd0\xd2\xdd\xe0\x61\x0b\x93\x6a\xfe\xb7\x6b\xc5\xfa\x47\x1e\xe7\xf8\x06\x9d\xd0\x3d\x8e\xe8\x9d\xc6\x18\x04\xcd\xc7\x24\xf0\x13\xda\x1f\x19\x74\xb8\xa6\xf1\x6c\x44\xd7\x7d\x6d\x51\x25\x38\x50\x60\x44\x8c\xc5\x09\xf3\xa1\x5a\x6e\xd0\xbd\x50\x6f\x31\x4f\x18\x04\x0f\x9a\x6d\xfc\x25\xe6\xdb\xfc\x99\xd2\x6b\x2c\x9f\x29\xeb\xc2\x2f\xb3\x37\x3c\xaf\x4b\x8c\x17\x45\x92\x27\x1e\x27\x37\x45\x34\xe6\xc3\xbb\x9a\x5d\x41\xc0\xe0\x46\x00\x01\x47\x77\x42\xa4\xb2\x1b\xa6\x5a\x2a\x63\xdd\x1c\x2a\x69\xdd\x89\xab\x41\x96\xe5\x51\x6e\x9a\xd6\x86\x66\xf2\x00\x4d\x26\x49\x2b\x10\x69\x65\xe9\x5f\x0c\x8a\xcc\x9c\x28\xfa\xb1\xa2\xc2\x11\x54\xfd\x19\x13\xfd\xbe\xd5\xef\xf6\xee\x08\x75\x16\x7a\xf4\xe1\x00\x47\xbb\x0b\x23\xcb\x5b\xb6\xaf\x9a\x54\x0e\x49\x91\xd6\x49\x43\x31\x99\xf2\x60\x69\xfc\xd9\xe8\xce\x74\x7f\x5b\x18\xe2\x75\x38\xfc\x1d\x09\x81\x3d\x62\x4c\xca\x0f\x97\xec\x7f\x01\x00\x00\xff\xff\x13\x58\x7e\xfd\x64\x0b\x00\x00")

func internal_internal_gs() ([]byte, error) {
	return bindata_read(
		_internal_internal_gs,
		"internal/internal.gs",
	)
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		return f()
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() ([]byte, error){
	"internal/internal.go": internal_internal_go,
	"internal/internal.gs": internal_internal_gs,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for name := range node.Children {
		rv = append(rv, name)
	}
	return rv, nil
}

type _bintree_t struct {
	Func     func() ([]byte, error)
	Children map[string]*_bintree_t
}

var _bintree = &_bintree_t{nil, map[string]*_bintree_t{
	"internal": &_bintree_t{nil, map[string]*_bintree_t{
		"internal.go": &_bintree_t{internal_internal_go, map[string]*_bintree_t{}},
		"internal.gs": &_bintree_t{internal_internal_gs, map[string]*_bintree_t{}},
	}},
}}
